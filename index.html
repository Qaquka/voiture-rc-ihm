<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>IHM ESP32 – Contrôles + Caméra / Caméra seule / Aide</title>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#9ca3af;
      --brand:#22c55e; --accent:#38bdf8; --danger:#ef4444; --warn:#f59e0b;
      --shadow:0 8px 22px rgba(0,0,0,.28);
      --radius:16px;
    }
    *{ box-sizing:border-box; }
    html,body{ margin:0; height:100%; background:linear-gradient(180deg,#0b1220,var(--bg)); color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans"; }
    header{
      position:sticky; top:0; z-index:5;
      display:flex; align-items:center; gap:12px; padding:10px 12px;
      background:rgba(255,255,255,.04); border-bottom:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px);
    }
    header img.logo{ height:44px; width:auto; border-radius:8px; background:rgba(255,255,255,.04); padding:4px; }
    .title{ display:flex; flex-direction:column; line-height:1.15; }
    .title h1{ margin:0; font-size:1.02rem; }
    .title small{ color:var(--muted); }
    .tabs{ margin-left:auto; display:flex; gap:8px; flex-wrap:wrap; }
    .tabbtn, .modebtn{
      background:#0b1220; color:var(--text); border:1px solid rgba(255,255,255,.16);
      padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600;
    }
    .tabbtn.active{ border-color:var(--accent); outline:2px solid var(--accent); }
    .modebtn{ margin-left:8px; white-space:nowrap; }
    main{ max-width:1100px; margin:14px auto 18px; padding:0 12px; }
    .card{ background:linear-gradient(180deg,var(--panel),#0b1220); border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden; }
    .card h2{ margin:0; padding:12px 14px; font-size:1rem; font-weight:600; background:rgba(255,255,255,.04);
      border-bottom:1px solid rgba(255,255,255,.08); display:flex; align-items:center; gap:10px;}
    .badge{ font-size:.75rem; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14); color:#fff; }
    .badge.ok{ background:rgba(16,185,129,.2); border-color:rgba(16,185,129,.6); }
    .badge.warn{ background:rgba(245,158,11,.2); border-color:rgba(245,158,11,.6); }
    .badge.err{ background:rgba(239,68,68,.2); border-color:rgba(239,68,68,.6); }
    .card .content{ padding:14px; }
    .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    input[type="text"]{ background:#0b1220; border:1px solid rgba(255,255,255,.16); color:var(--text);
      border-radius:10px; padding:10px 12px; min-width:220px; outline:none; }
    button.link{ background:#0b1220; color:var(--text); border:1px solid rgba(255,255,255,.2);
      padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
    button.link.primary{ border-color:var(--accent); }
    button.link.danger{ border-color:var(--danger); }
    .status{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:8px; color:var(--muted); }
    .dot{ width:10px; height:10px; border-radius:999px; background:var(--danger); box-shadow:0 0 0 2px rgba(0,0,0,.3) inset; }
    .dot.ok{ background:var(--brand); }
    .dot.warn{ background:var(--warn); }
    .muted{ color:var(--muted); }
    .stream{ width:100%; aspect-ratio:16/9; background:#000; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.08); position:relative; }
    .stream img{ width:100%; height:100%; object-fit:contain; display:block; background:#000; }
    .fit-fill .stream img{ object-fit:cover; }
    .stream .alert{ position:absolute; inset:auto 8px 8px 8px; background:rgba(239,68,68,.95); color:#fff;
      border-radius:10px; padding:10px 12px; font-size:.9rem; display:none; }
    .stream.error .alert{ display:block; }
    .meta{ display:flex; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:.92rem; }
    .tag{ padding:4px 8px; border:1px solid rgba(255,255,255,.08); border-radius:999px; }

    /* Grille commandes */
    .controls{ display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:12px; max-width:420px; margin:auto; }
    .btn{ user-select:none; cursor:pointer; text-align:center; border-radius:14px; padding:14px 12px; background:#111827;
      border:1px solid rgba(255,255,255,.1); box-shadow:var(--shadow); font-weight:600; transition: transform .05s ease, border-color .2s ease; }
    .btn:active,.btn.down{ transform: scale(.98); outline:2px solid var(--accent); border-color:var(--accent); }
    .btn[data-dir="stop"]{ grid-column:1/-1; background:#1f2937; }

    /* Views */
    .view{ display:none; }
    .view.active{ display:block; }

    /* Plein écran conteneur */
    .stream:fullscreen{ width:100vw; height:100vh; border-radius:0; border:none; background:#000; }
    .stream:fullscreen img{ width:100%; height:100%; object-fit:contain; background:#000; }
    .stream:-webkit-full-screen{ width:100vw; height:100vh; border-radius:0; border:none; background:#000; }
    .stream:-webkit-full-screen img{ width:100%; height:100%; object-fit:contain; background:#000; }

    .foot{ text-align:center; padding:10px; color:var(--muted); font-size:.85rem;
      border-top:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.03); }

    /* Toasts */
    #toast{ position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
      display: grid; gap: 8px; z-index: 9999; width: min(92vw, 520px); }
    .toast{ border-radius: 12px; padding: 10px 12px; background: rgba(17,24,39,.95); color: #fff;
      border: 1px solid rgba(255,255,255,.12); box-shadow: var(--shadow); font-size: .95rem;
      display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .toast.ok{ background: rgba(16,185,129,.95); }
    .toast.warn{ background: rgba(245,158,11,.95); }
    .toast.err{ background: rgba(239,68,68,.95); }
    .toast button{ background: rgba(255,255,255,.15); border: none; color: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; }

    /* MODE MOBILE */
    body.mobile-mode header{ padding:8px 10px; }
    body.mobile-mode header img.logo{ height:36px; padding:3px; }
    body.mobile-mode .title h1{ font-size:.95rem; }
    body.mobile-mode .title small{ font-size:.8rem; }
    body.mobile-mode main{ max-width:100%; padding:0 8px; margin:10px auto 14px; }
    body.mobile-mode .card h2{ padding:10px 12px; font-size:.95rem; }
    body.mobile-mode .card .content{ padding:10px; }
    body.mobile-mode .row{ gap:8px; }
    body.mobile-mode #view-full .row input[type="text"]{ display:none; }
    body.mobile-mode #view-full #openCamOnly{ display:none; }
    body.mobile-mode #view-cam .row input[type="text"]{ display:none; }
    body.mobile-mode #view-full .stream{ aspect-ratio:auto; height: calc(100vh - 260px); }
    body.mobile-mode #view-cam .stream{ height: calc(100vh - 160px); }
    body.mobile-mode .tabbtn, body.mobile-mode .modebtn, body-mobile-mode button.link{ padding:10px 14px; border-radius:12px; }
    body.mobile-mode .btn{ padding:18px 14px; font-size:1.05rem; }

    /* ========= HUD (overlay) ========= */
    .hud{
      position:absolute; bottom:0; left:0; right:0;
      display:flex; justify-content:center; gap:28px; align-items:center; flex-wrap:wrap;
      background:rgba(0,0,0,.45); border-top:1px solid rgba(255,255,255,.18);
      color:#fff; padding:10px 14px; font-weight:700; z-index:3;
    }
    .hud .label{ font-size:.85rem; opacity:.9; }
    .hud .val{ font-size:1.15rem; line-height:1; }
    .hud .unit{ font-size:.9rem; opacity:.9; }

    /* Vitesse numérique GROS */
    .speedBig{
      display:flex; align-items:baseline; gap:10px;
      font-size:3rem; line-height:1; letter-spacing:1px;
      text-shadow:0 2px 6px rgba(0,0,0,.6);
      min-width:150px; justify-content:center;
    }
    .speedBig .num{ font-size:3.2rem; font-variant-numeric: tabular-nums; }
    .speedBig .unit{ font-size:1rem; opacity:.9; margin-bottom:4px; }

    /* Batterie segments */
    .batt{
      display:flex; align-items:center; gap:6px;
    }
    .batt-pack{
      display:grid; grid-auto-flow:column; gap:2px; padding:2px 4px; border-radius:6px;
      border:1px solid rgba(255,255,255,.45);
    }
    .cell{ width:10px; height:16px; background:#334155; border-radius:2px; transition:background .2s ease, transform .2s ease; }
    .cell.on{ background:#22c55e; }
    .cell.mid{ background:#f59e0b; }
    .cell.low{ background:#ef4444; }
    .blink{ animation: blink 1s infinite; }
    @keyframes blink { 0%,60%{opacity:1} 61%,100%{opacity:.2} }

    /* Ping badge */
    .ping-badge{ padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); font-size:.85rem; }
    .ping-ok{ background:rgba(16,185,129,.18); border-color:rgba(16,185,129,.55); }
    .ping-warn{ background:rgba(245,158,11,.18); border-color:rgba(245,158,11,.55); }
    .ping-err{ background:rgba(239,68,68,.18); border-color:rgba(239,68,68,.55); }

    /* Barre touches actives */
    .keys{ display:flex; gap:6px; align-items:center; font-size:.9rem; color:var(--muted); }
    .key{ border:1px solid rgba(255,255,255,.2); padding:2px 6px; border-radius:6px; min-width:20px; text-align:center;}
    .key.on{ background:rgba(56,189,248,.15); border-color:rgba(56,189,248,.6); color:#fff;}

  </style>
</head>
<body>
  <header id="appHeader">
    <img id="logo" class="logo" src="iut_univ_blanc.png" alt="Logo université" />
    <div class="title">
      <h1>IHM Voiture RC - GEII</h1>
      <small id="team">Groupe 2 Voiture RC</small>
    </div>
    <div class="tabs">
      <button id="tabFull" class="tabbtn active" data-view="full">Contrôles + Caméra</button>
      <button id="tabCam" class="tabbtn" data-view="cam">Caméra seule</button>
      <button id="tabHelp" class="tabbtn" data-view="help">Aide</button>
      <button id="btnMode" class="modebtn" title="Basculer l’affichage">Mode mobile</button>
    </div>
  </header>

  <main>
    <!-- ========================= VUE FULL ========================= -->
    <section id="view-full" class="view active">
      <div class="card" id="cardVideo">
        <h2>
          Flux vidéo
          <span class="badge" id="fpsBadge" title="Images/seconde estimées">FPS --</span>
          <button id="btnFit" class="link" style="margin-left:auto">Ajustement: Contain</button>
          <button id="btnSnapshot" class="link">Snapshot</button>
        </h2>
        <div class="content">
          <div class="status">
            <span>Statut :</span><span id="wsDot" class="dot"></span><span id="wsStatus">déconnecté</span>
            <div class="keys" aria-label="Touches">
              <span class="key" id="kUp">↑</span><span class="key" id="kLeft">←</span>
              <span class="key" id="kDown">↓</span><span class="key" id="kRight">→</span>
              <span class="key" id="kSpace">␣</span>
            </div>
          </div>
          <div class="stream" id="streamFullWrap">
            <!-- === HUD FULL === -->
            <div class="hud" id="hudFull" aria-live="polite">
              <!-- Vitesse numérique BIG -->
              <div class="speedBig" aria-label="Vitesse actuelle">
                <span class="num" id="speedValBig">0</span>
                <span class="unit">KM/H</span>
              </div>

              <!-- Batterie segments -->
              <div class="batt">
                <span class="label">Batt.</span>
                <div class="batt-pack" id="battPack" aria-hidden="true">
                  <span class="cell"></span><span class="cell"></span><span class="cell"></span><span class="cell"></span><span class="cell"></span>
                </div>
                <span class="val" id="battVal">--</span><span class="unit">%</span>
              </div>

              <!-- Ping -->
              <div class="rtt">
                <span class="ping-badge" id="pingBadge">Ping --ms</span>
              </div>
            </div>
            <!-- === /HUD FULL === -->

            <img id="imgFull" src="http://adresse_ESP32:81/stream" decoding="async" alt="Flux caméra ESP32 (MJPEG)">
            <div class="alert" id="alertFull">Flux vidéo indisponible. Vérifiez l’URL, le réseau, ou redémarrez la caméra. <button id="retryFull" class="link" style="margin-left:8px">Réessayer</button></div>
          </div>
          <div class="row" style="margin-top:10px">
            <input id="streamUrl" type="text" value="http://adresse_ESP32:81/stream" aria-label="URL flux MJPEG">
            <button id="applyStream" class="link primary">Appliquer</button>
            <button id="reloadStream" class="link">Recharger</button>
            <button id="disconnectStream" class="link danger">Déconnecter le flux</button>
            <button id="openCamOnly" class="link">Ouvrir la vue caméra seule (nouvel onglet)</button>
          </div>
          <div class="meta" style="margin-top:8px">
            <span class="tag">Touches: ↑ ↓ ← → ou ZQSD</span>
            <span class="tag">Espace = STOP</span>
            <span class="tag">Maintenir = mouvement continu</span>
          </div>
        </div>
        <div class="foot">Si le flux ne s'affiche pas, vérifiez l'URL MJPEG (ex. <code>http://192.168.4.1:81/stream</code>).</div>
      </div>

      <div class="card" style="margin-top:14px">
        <h2>Contrôle de la voiture</h2>
        <div class="content">
          <div class="row" style="margin-bottom:10px">
            <input id="wsUrl" type="text" value="ws://adresse_ESP32/ws" aria-label="URL WebSocket">
            <input id="httpBase" type="text" value="http://adresse_ESP32" aria-label="Base HTTP">
            <button id="btnConnect" class="link primary">Connexion </button>
            <button id="btnDisconnect" class="link">Déconnexion</button>
            <button id="btnPing" class="link">Ping</button>
            <button id="btnStop" class="link danger">STOP</button>
          </div>

          <div class="controls" aria-label="Boutons de direction">
            <div></div>
            <div class="btn" data-dir="forward" aria-label="Avancer (↑ / Z)">↑ / Z</div>
            <div></div>

            <div class="btn" data-dir="left" aria-label="Gauche (← / Q)">← / Q</div>
            <div class="btn" data-dir="backward" aria-label="Reculer (↓ / S)">↓ / S</div>
            <div class="btn" data-dir="right" aria-label="Droite (→ / D)">→ / D</div>

            <div></div>
            <div class="btn" data-dir="stop" aria-label="Stop (Espace)">STOP</div>
            <div></div>
          </div>
        </div>
        <div class="foot">Fallback HTTP automatique si WS indisponible : <code>/cmd?c=F|B|L|R|S</code>.</div>
      </div>
    </section>

    <!-- ========================= VUE CAM ONLY ========================= -->
    <section id="view-cam" class="view">
      <div class="card">
        <h2>Caméra seule (vue mobile)</h2>
        <div class="content">
          <div class="row">
            <div class="muted">Plein écran vidéo + anti-veille pour smartphone :</div>
            <div class="tools">
              <button id="btnFS" class="link">Plein écran vidéo</button>
              <button id="btnWake" class="link">Anti-veille</button>
              <button id="btnReload" class="link">Recharger</button>
            </div>
          </div>
          <div class="stream" id="streamCamWrap" style="margin-top:10px">
            <!-- === HUD CAM === -->
            <div class="hud" id="hudCam" aria-live="polite">
              <div style="display:flex;align-items:baseline;gap:6px;font-weight:800;">
                <span id="speedValCam" style="font-size:2rem;line-height:1;font-variant-numeric:tabular-nums">0.0</span>
                <span class="unit">km/h</span>
              </div>
              <div class="batt">
                <span class="label">Batt.</span>
                <div class="batt-pack" id="battPackCam" aria-hidden="true">
                  <span class="cell"></span><span class="cell"></span><span class="cell"></span><span class="cell"></span><span class="cell"></span>
                </div>
                <span class="val" id="battValCam">--</span><span class="unit">%</span>
              </div>
              <div class="rtt">
                <span class="ping-badge" id="pingBadgeCam">Ping --ms</span>
              </div>
            </div>
            <!-- === /HUD CAM === -->
            <img id="imgCam" src="http://adresse_ESP32:81/stream" decoding="async" alt="Flux caméra ESP32 (MJPEG)">
            <div class="alert" id="alertCam">Flux vidéo indisponible. Vérifiez l’URL, le réseau, ou redémarrez la caméra. <button id="retryCam" class="link" style="margin-left:8px">Réessayer</button></div>
          </div>

          <div class="row" style="margin-top:10px">
            <input id="streamUrlCam" type="text" value="http://adresse_ESP32:81/stream" aria-label="URL flux MJPEG (caméra seule)">
            <button id="applyStreamCam" class="link primary">Appliquer</button>
            <button id="reloadStreamCam" class="link">Recharger</button>
            <button id="disconnectStreamCam" class="link danger">Déconnecter le flux</button>
          </div>
        </div>
        <div class="foot">Astuce : tournez le téléphone en paysage pour une meilleure visibilité. Le plein écran est demandé uniquement pour l’élément vidéo.</div>
      </div>
    </section>

    <!-- ========================= VUE HELP ========================= -->
    <section id="view-help" class="view help">
      <div class="card">
        <h2>Aide – Mise en route & utilisation</h2>
        <div class="content">
          <ol>
            <li><strong>Connectez-vous au réseau de l’ESP32</strong> (AP <code>192.168.4.1</code> ou votre réseau local).</li>
            <li><strong>Ouvrez ce fichier</strong> sur votre navigateur (PC ou smartphone).</li>
            <li>Dans l’onglet <em>Contrôles + Caméra</em>, entrez :
              <ul>
                <li><strong>Flux MJPEG</strong> : ex. <code>http://192.168.4.1:81/stream</code>.</li>
                <li><strong>WebSocket</strong> : ex. <code>ws://192.168.4.1/ws</code> (si disponible).</li>
                <li><strong>Base HTTP</strong> : ex. <code>http://192.168.4.1</code> (fallback).</li>
              </ul>
            </li>
            <li>Cliquez <strong>Connexion</strong> (facultatif). Sinon, les commandes passent en <em>HTTP</em> (GET <code>/cmd?c=F|B|L|R|S</code>).</li>
            <li><strong>Contrôles</strong> : flèches ou ZQSD ; <code>Espace</code>=STOP. Maintenir pour mouvement continu.</li>
            <li>Pour une vue pilote sur smartphone : onglet <em>Caméra seule</em> → <em>Plein écran vidéo</em> + <em>Anti-veille</em>.</li>
          </ol>
        </div>
      </div>
    </section>
  </main>

  <div id="toast" aria-live="polite" aria-atomic="true"></div>

  <script>
    // ===== Helpers & defaults =====
    const $=(s,r=document)=>r.querySelector(s);
    const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
    const qp=new URLSearchParams(location.search);
    const DEFAULTS={
      STREAM_URL:"http://webcam.privcom.ch/mjpg/video.mjpg", // <— DEMO
      WS_URL:"ws://adresse_ESP32/ws",
      HTTP_BASE:"http://adresse_ESP32",
      LOGO_URL: "iut_univ_blanc.png",
      TEAM_TXT:"Groupe 2 Voiture RC"
    };

    // Toast (queue simple)
    function notify(msg, level="err", actions=[]){
      const wrap=$("#toast");
      const el=document.createElement("div");
      el.className=`toast ${level}`;
      const btns = actions.map(a=>`<button data-act="${a.id||'act'}">${a.label}</button>`).join("");
      el.innerHTML=`<span>${msg}</span><span>${btns}</span>`;
      wrap.appendChild(el);
      actions.forEach(a=>{
        const b = el.querySelector(`button[data-act="${a.id||'act'}"]`);
        if(b) b.addEventListener("click", ()=>{ try{ a.onClick?.(); }catch{}; el.remove(); });
      });
      setTimeout(()=>{ try{ el.remove(); }catch{}; }, Math.max(3500, 1500 + msg.length*25));
    }

    const param = (key, fallback)=> qp.get(key) || fallback;
    const DEMO = qp.get("demo")==="1";

    // Header
    const logoEl=$("#logo"), teamEl=$("#team");
    logoEl.src = param("logo", DEFAULTS.LOGO_URL);
    logoEl.addEventListener("error", ()=>{ if(!logoEl.dataset.fallback){ logoEl.dataset.fallback="1"; logoEl.src="iut_univ_blanc.png"; }});
    teamEl.textContent = "Équipe : " + decodeURIComponent(param("team", encodeURIComponent(DEFAULTS.TEAM_TXT)));

    // Tabs
    const tabFull=$("#tabFull"), tabCam=$("#tabCam"), tabHelp=$("#tabHelp");
    const viewFull=$("#view-full"), viewCam=$("#view-cam"), viewHelp=$("#view-help");
    function setView(v){
      const isFull = v==="full", isCam = v==="cam", isHelp = v==="help";
      viewFull.classList.toggle("active", isFull);
      viewCam.classList.toggle("active", isCam);
      viewHelp.classList.toggle("active", isHelp);
      tabFull.classList.toggle("active", isFull);
      tabCam.classList.toggle("active", isCam);
      tabHelp.classList.toggle("active", isHelp);
      const url=new URL(location.href); url.searchParams.set("view", v); history.replaceState(null,"",url);
      if(isCam){ attemptVideoFullscreen(); }
    }
    setView(param("view","full"));
    tabFull.addEventListener("click", ()=>setView("full"));
    tabCam.addEventListener("click",  ()=>setView("cam"));
    tabHelp.addEventListener("click", ()=>setView("help"));

    // ===== Mode UI
    const btnMode = $("#btnMode");
    function setUIMode(mode){
      const isMobile = (mode === "mobile");
      document.body.classList.toggle("mobile-mode", isMobile);
      btnMode.textContent = isMobile ? "Mode desktop" : "Mode mobile";
      const url=new URL(location.href);
      url.searchParams.set("mode", isMobile ? "mobile" : "desktop");
      history.replaceState(null,"",url);
      try{ localStorage.setItem("uiMode", isMobile ? "mobile":"desktop"); }catch{}
    }
    (function initMode(){
      const fromQP = qp.get("mode");
      if(fromQP){ setUIMode(fromQP); return; }
      try{
        const saved = localStorage.getItem("uiMode");
        if(saved) setUIMode(saved);
      }catch{}
    })();
    btnMode.addEventListener("click", ()=>{
      const isMobile = document.body.classList.contains("mobile-mode");
      setUIMode(isMobile ? "desktop" : "mobile");
    });

    // ===== Streams
    const imgFull=$("#imgFull"), imgCam=$("#imgCam");
    const streamUrl=$("#streamUrl"), streamUrlCam=$("#streamUrlCam");
    const applyStream=$("#applyStream"), reloadStream=$("#reloadStream");
    const applyStreamCam=$("#applyStreamCam"), reloadStreamCam=$("#reloadStreamCam");
    const streamFullWrap=$("#streamFullWrap"), streamCamWrap=$("#streamCamWrap");
    const retryFull=$("#retryFull"), retryCam=$("#retryCam");
    const btnDisconnectStream = $("#disconnectStream");
    const btnDisconnectStreamCam = $("#disconnectStreamCam");
    const fpsBadge=$("#fpsBadge"); let _lastFrameAt=null, _fpsAvg=0;

    const streamDefault = param("stream", DEMO?DEFAULTS.STREAM_URL:DEFAULTS.STREAM_URL);
    setStream(streamDefault);

    function setStream(url){
      imgFull.src = url; imgCam.src = url;
      streamUrl.value = url; streamUrlCam.value = url;
      clearStreamError(true); clearStreamError(false);
    }
    function reloadImg(img){
      try{
        const u=new URL(img.src, location.href);
        u.searchParams.set("_", Date.now());
        img.src=u.toString();
      }catch{}
    }
    function showStreamError(full, message){
      const wrap = full ? streamFullWrap : streamCamWrap;
      wrap.classList.add("error");
      const alert = full ? $("#alertFull") : $("#alertCam");
      alert.firstChild.textContent = message || "Flux vidéo indisponible.";
    }
    function clearStreamError(full){
      const wrap = full ? streamFullWrap : streamCamWrap;
      wrap.classList.remove("error");
    }
    function updateFPS(){
      const now=performance.now();
      if(_lastFrameAt!=null){
        const dt = (now-_lastFrameAt)/1000;
        const fps = 1/dt;
        _fpsAvg = _fpsAvg*0.8 + fps*0.2;
        if(fpsBadge) fpsBadge.textContent = "FPS " + Math.max(0,Math.round(_fpsAvg)).toString().padStart(2,"0");
        // badge couleur
        fpsBadge.className="badge " + (_fpsAvg>20?"ok":_fpsAvg>10?"warn":"err");
      }
      _lastFrameAt=now;
    }
    imgFull.addEventListener("load", ()=>{ clearStreamError(true); updateFPS(); });
    imgCam.addEventListener("load",  ()=> clearStreamError(false));
    imgFull.addEventListener("error", ()=>{
      showStreamError(true, "Flux vidéo indisponible (URL invalide, caméra arrêtée ou réseau HS).");
      notify("Erreur flux vidéo (vue complète). Vérifiez l’URL ou la connexion.", "err", [{id:"r",label:"Réessayer",onClick:()=>reloadImg(imgFull)}]);
    });
    imgCam.addEventListener("error", ()=>{
      showStreamError(false, "Flux vidéo indisponible (URL invalide, caméra arrêtée ou réseau HS).");
      notify("Erreur flux vidéo (vue caméra). Vérifiez l’URL ou la connexion.", "err", [{id:"r",label:"Réessayer",onClick:()=>reloadImg(imgCam)}]);
    });
    applyStream.addEventListener("click", ()=>{
      const u=(streamUrl.value||"").trim();
      if(u){ setStream(u); } else { notify("URL de flux vide.", "warn"); }
    });
    reloadStream.addEventListener("click", ()=> reloadImg(imgFull));
    applyStreamCam.addEventListener("click", ()=>{
      const u=(streamUrlCam.value||"").trim();
      if(u){ setStream(u); } else { notify("URL de flux vide.", "warn"); }
    });
    reloadStreamCam.addEventListener("click", ()=> reloadImg(imgCam));
    retryFull.addEventListener("click", ()=> reloadImg(imgFull));
    retryCam.addEventListener("click",  ()=> reloadImg(imgCam));

    function disconnectStream(img, full){
      try{ img.src = ""; }catch{}
      const wrap  = full ? streamFullWrap : streamCamWrap;
      const alert = full ? $("#alertFull") : $("#alertCam");
      if (wrap)  wrap.classList.add("error");
      if (alert) alert.firstChild.textContent = "Flux déconnecté par l’utilisateur.";
      notify("Flux vidéo déconnecté.", "warn");
    }
    if (btnDisconnectStream)    btnDisconnectStream.addEventListener("click", ()=> disconnectStream(imgFull, true));
    if (btnDisconnectStreamCam) btnDisconnectStreamCam.addEventListener("click", ()=> disconnectStream(imgCam,  false));

    // Ajustement vidéo
    const cardVideo=$("#cardVideo"), btnFit=$("#btnFit");
    btnFit.addEventListener("click", ()=>{
      cardVideo.classList.toggle("fit-fill");
      btnFit.textContent = "Ajustement: " + (cardVideo.classList.contains("fit-fill")?"Fill":"Contain");
    });

    // Snapshot (si CORS ok)
    $("#btnSnapshot").addEventListener("click", async ()=>{
      try{
        const canvas=document.createElement("canvas");
        canvas.width=imgFull.naturalWidth||1280; canvas.height=imgFull.naturalHeight||720;
        const ctx=canvas.getContext("2d");
        ctx.drawImage(imgFull,0,0,canvas.width,canvas.height);
        const a=document.createElement("a");
        a.href=canvas.toDataURL("image/png");
        a.download=`snapshot_${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
        a.click();
        notify("Snapshot enregistré.", "ok");
      }catch{
        notify("Snapshot impossible (CORS). Essayez depuis le même domaine que la caméra.", "warn");
      }
    });

    // Onglet cam seul
    $("#openCamOnly").addEventListener("click", ()=>{
      const u = (streamUrl.value||DEFAULTS.STREAM_URL).trim();
      const url = `${location.pathname}?view=cam&stream=${encodeURIComponent(u)}&logo=${encodeURIComponent(logoEl.src)}&team=${encodeURIComponent(teamEl.textContent.replace(/^Équipe :\s*/,''))}`;
      window.open(url, "_blank");
    });

    // ===== WebSocket + HTTP fallback + reconnexion
    const wsUrlEl=$("#wsUrl"), httpBaseEl=$("#httpBase");
    const btnConnect=$("#btnConnect"), btnDisconnect=$("#btnDisconnect");
    const btnPing=$("#btnPing"), btnStop=$("#btnStop");
    const wsDot=$("#wsDot"), wsStatus=$("#wsStatus");

    wsUrlEl.value = param("ws", DEFAULTS.WS_URL);
    httpBaseEl.value = param("http", DEFAULTS.HTTP_BASE);

    let ws=null, reconnectTry=0, reconnectTimer=null;
    let lastPingAt = null, heartbeatTimer=null;

    const setWsStatus=(open,txt,level)=>{
      wsDot.classList.remove("warn","ok");
      wsDot.classList.toggle("ok",!!open);
      if(level==="warn") wsDot.classList.add("warn");
      wsStatus.textContent=txt || (open?"connecté":"déconnecté");
    };

    function scheduleReconnect(){
      if(DEMO) return; // inutile en démo
      if(reconnectTimer) return;
      const delay = Math.min(8000, 500 * Math.pow(2, reconnectTry++));
      reconnectTimer = setTimeout(()=>{ reconnectTimer=null; connectWS(); }, delay);
      notify("Tentative de reconnexion WS dans " + Math.round(delay/1000) + "s…", "warn");
    }

    function startHeartbeat(){
      stopHeartbeat();
      heartbeatTimer = setInterval(()=>{
        if(!ws || ws.readyState!==WebSocket.OPEN) return;
        try{ lastPingAt = performance.now(); ws.send("PING"); }catch{}
      }, 5000);
    }
    function stopHeartbeat(){ if(heartbeatTimer){ clearInterval(heartbeatTimer); heartbeatTimer=null; } }

    function connectWS(){
      const url=wsUrlEl.value.trim();
      if(!/^wss?:\/\//i.test(url)){
        notify("URL WebSocket invalide (ex: ws://192.168.4.1/ws)", "warn");
        return;
      }
      try{ if(ws&&ws.readyState===WebSocket.OPEN) ws.close(); }catch{}
      setWsStatus(false,"connexion…","warn");
      try{ ws=new WebSocket(url); }
      catch(e){ notify("Échec d’ouverture WebSocket.", "err"); setWsStatus(false,"erreur"); scheduleReconnect(); return; }

      ws.addEventListener("open", ()=>{ setWsStatus(true,"connecté"); notify("WebSocket connectée.", "ok"); reconnectTry=0; startHeartbeat(); });
      ws.addEventListener("close",()=>{ setWsStatus(false,"déconnecté"); notify("WebSocket déconnectée.", "warn"); stopHeartbeat(); scheduleReconnect(); });
      ws.addEventListener("error",()=>{ setWsStatus(false,"erreur"); notify("Erreur WebSocket (réseau / serveur).", "err"); });

      // Réception télémétrie
      ws.addEventListener("message",(ev)=>{
        try{
          let payload = {};
          try{ const obj = JSON.parse(ev.data); if(obj && typeof obj === "object") payload = obj; }
          catch{
            const s = String(ev.data).trim();
            const mSpd = s.match(/^SPD\s*:\s*([+-]?\d+(?:\.\d+)?)$/i);
            const mBat = s.match(/^BATT\s*:\s*([+-]?\d+(?:\.\d+)?)$/i);
            const mPing= s.match(/^PING\s*:\s*([+-]?\d+(?:\.\d+)?)$/i);
            if(mSpd) payload.speed = parseFloat(mSpd[1]);
            if(mBat) payload.battery = parseFloat(mBat[1]);
            if(mPing) payload.ping = parseFloat(mPing[1]);
            if(/^PONG(?:[:\s]\d+)?$/i.test(s) && lastPingAt!=null){
              const rtt = Math.round(performance.now() - lastPingAt);
              updatePing(rtt); lastPingAt=null;
            }
          }
          if("speed" in payload)   updateSpeed(payload.speed);
          if("battery" in payload) updateBattery(payload.battery);
          if("ping" in payload)    updatePing(payload.ping);
        }catch{}
      });
    }
    function disconnectWS(){
      try{ if(ws) ws.close(); }catch{}
      stopHeartbeat();
      setWsStatus(false,"déconnecté");
      notify("WebSocket déconnectée.", "warn");
    }
    async function sendOverHTTP(cmd){
      const base=httpBaseEl.value.trim().replace(/\/+$/,"");
      if(!/^https?:\/\//i.test(base)){ notify("Base HTTP invalide (ex: http://192.168.4.1)", "warn"); return; }
      try{
        const res = await fetch(`${base}/cmd?c=${encodeURIComponent(cmd)}`,{cache:"no-store"});
        if(!res.ok){ notify(`HTTP ${res.status} lors de l'envoi de la commande.`, "warn"); }
        else{ notify("Commande envoyée (HTTP).", "ok"); }
      }catch{
        notify("Erreur réseau HTTP (commande non envoyée).", "err");
      }
    }
    function sendCommand(cmd){
      if(ws&&ws.readyState===WebSocket.OPEN){
        try{ ws.send(cmd); return; }catch{ notify("Échec envoi WS, bascule HTTP.", "warn"); }
      }
      sendOverHTTP(cmd);
    }
    $("#btnConnect").addEventListener("click", connectWS);
    $("#btnDisconnect").addEventListener("click", disconnectWS);
    $("#btnPing").addEventListener("click", ()=>{
      if(ws && ws.readyState===WebSocket.OPEN){
        lastPingAt = performance.now(); try{ ws.send("PING"); }catch{}
      }else{
        notify("WS non connecté : impossible de mesurer le ping (RTT).", "warn");
      }
    });
    $("#btnStop").addEventListener("click", ()=> sendCommand("S"));

    // ===== Plein écran CONTAINER + Wake Lock
    const btnFS=$("#btnFS"), btnReload=$("#btnReload");
    function requestFullscreenOn(el){
      if(!el) return;
      if (el.requestFullscreen) { el.requestFullscreen().catch(()=>{}); return; }
      if (el.webkitRequestFullscreen) { try{ el.webkitRequestFullscreen(); }catch{} }
    }
    if(btnFS){
      btnFS.addEventListener("click", ()=>{
        requestFullscreenOn(document.getElementById("streamCamWrap"));
        enableWakeLock();
      });
    }
    if(btnReload){ btnReload.addEventListener("click", ()=> reloadImg(imgCam)); }

    let wakeLock=null;
    async function enableWakeLock(){
      try{
        if(!wakeLock){
          wakeLock = await navigator.wakeLock.request("screen");
          notify("Anti-veille activé (si supporté).", "ok");
          wakeLock.addEventListener("release", ()=>{ wakeLock=null; notify("Anti-veille relâché.", "warn"); });
        }
      }catch{/* non supporté */}
    }
    async function attemptVideoFullscreen(fromButton=false){
      const wrap = document.getElementById("streamCamWrap");
      if(!wrap) return;
      try{
        if(document.fullscreenElement !== wrap){
          if (wrap.requestFullscreen) { await wrap.requestFullscreen(); }
          else if (wrap.webkitRequestFullscreen) { wrap.webkitRequestFullscreen(); }
          if(!fromButton) notify("Plein écran (HUD) demandé.", "ok");
        }
      }catch{}
      enableWakeLock();
    }

    // ====== VITESSE (numérique) + batterie + ping
    const speedValBig = $("#speedValBig");
    const speedValCam = $("#speedValCam");

    let _speedDisp = 0; // km/h (lissé)

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    function setSpeedDisplay(v){
      const n = clamp(v, 0, 999);
      _speedDisp = n;
      if(speedValBig) speedValBig.textContent = Math.round(n).toString();
      if(speedValCam) speedValCam.textContent = n.toFixed(1);
    }

    // Lissage court pour un rendu propre
    function updateSpeed(v){
      const target = Number.isFinite(v) ? v : 0;
      const frames = 5;
      let i=0; const start=_speedDisp; const delta=target-start;
      (function step(){
        i++; setSpeedDisplay(start + delta*(i/frames));
        if(i<frames) requestAnimationFrame(step);
      })();
    }

    // Batterie segments
    const battVal = $("#battVal"), battValCam = $("#battValCam");
    const battPack = $("#battPack"), battPackCam = $("#battPackCam");
    function setCells(pack, pct){
      if(!pack) return;
      const cells = Array.from(pack.querySelectorAll(".cell"));
      const lit = Math.round((pct/100)*cells.length);
      cells.forEach((c,idx)=>{
        c.className="cell";
        if(idx<lit){
          const ratio = pct/100;
          if(ratio<0.2) c.classList.add("low");
          else if(ratio<0.5) c.classList.add("mid");
          else c.classList.add("on");
        }
      });
      if(pct<10) pack.classList.add("blink"); else pack.classList.remove("blink");
    }
    function updateBattery(pct){
      if(!Number.isFinite(pct)) return;
      const n = clamp(pct, 0, 100);
      if(battVal) battVal.textContent = String(Math.round(n));
      if(battValCam) battValCam.textContent = String(Math.round(n));
      setCells(battPack,n); setCells(battPackCam,n);
    }

    // Ping badge couleurs
    const pingBadge=$("#pingBadge"), pingBadgeCam=$("#pingBadgeCam");
    function updatePing(ms){
      if(!Number.isFinite(ms)) return;
      const n = Math.max(0, Math.round(ms));
      const cls = n<60?"ping-ok":(n<150?"ping-warn":"ping-err");
      if(pingBadge){ pingBadge.className="ping-badge "+cls; pingBadge.textContent="Ping "+n+"ms"; }
      if(pingBadgeCam){ pingBadgeCam.className="ping-badge "+cls; pingBadgeCam.textContent="Ping "+n+"ms"; }
    }

    // ===== Indicateur touches + contrôle clavier
    const keyEls={ArrowUp:$("#kUp"), ArrowLeft:$("#kLeft"), ArrowDown:$("#kDown"), ArrowRight:$("#kRight"), Space:$("#kSpace")};
    const pressed=new Set();
    const KeyMap={"ArrowUp":"F","KeyZ":"F","ArrowDown":"B","KeyS":"B","ArrowLeft":"L","KeyQ":"L","ArrowRight":"R","KeyD":"R","Space":"S"};
    function sendDir(code, down){
      const cmd = KeyMap[code]; if(!cmd) return;
      if(cmd==="S"){ sendCommand("S"); return; }
      if(down){ sendCommand(cmd); } else { sendCommand("S"); }
    }
    window.addEventListener("keydown",(e)=>{
      const c=e.code; if(!(c in KeyMap)) return;
      if(!viewFull.classList.contains("active")) return;
      e.preventDefault(); if(pressed.has(c)) return; pressed.add(c);
      keyEls[e.code]?.classList.add("on");
      sendDir(c,true);
    },{passive:false});
    window.addEventListener("keyup",(e)=>{
      const c=e.code; if(!(c in KeyMap)) return;
      if(!viewFull.classList.contains("active")) return;
      e.preventDefault(); pressed.delete(c);
      keyEls[e.code]?.classList.remove("on");
      sendDir(c,false);
    },{passive:false});
    window.addEventListener("blur", ()=> sendCommand("S"));
    document.addEventListener("visibilitychange", ()=>{ if(document.hidden) sendCommand("S"); });

    // ===== Gamepad (basique)
    let gpRAF=null;
    window.addEventListener("gamepadconnected", (e)=>{
      notify("Manette connectée.", "ok");
      const loop=()=>{
        const gp=navigator.getGamepads?.()[e.gamepad.index];
        if(gp){
          const axY = gp.axes[1]||0; const axX = gp.axes[0]||0;
          const btnA = gp.buttons[0]?.pressed; // STOP
          if(btnA) sendCommand("S");
          else{
            if(axY<-0.3) sendCommand("F");
            else if(axY>0.3) sendCommand("B");
            else if(axX<-0.3) sendCommand("L");
            else if(axX>0.3) sendCommand("R");
          }
        }
        gpRAF=requestAnimationFrame(loop);
      };
      if(!gpRAF) gpRAF=requestAnimationFrame(loop);
    });
    window.addEventListener("gamepaddisconnected", ()=>{
      if(gpRAF){ cancelAnimationFrame(gpRAF); gpRAF=null; }
      notify("Manette déconnectée.", "warn");
    });

    // ===== Mode DEMO (simulateur simple)
    if(DEMO){
      notify("Mode démo actif : données simulées.", "ok");
      setInterval(()=>{
        const t=performance.now()/1000;
        updateSpeed( 12 + 10*Math.sin(t*1.2) + 2*Math.cos(t*0.4) );
        updateBattery( 60 + 40*Math.sin(t*0.05) );
        updatePing( 40 + 40*(1+Math.sin(t*0.8)) );
      }, 300);
    }

    // Raccourci F pour plein écran vidéo (vue cam)
    document.addEventListener("keydown",(e)=>{
      if(e.key.toLowerCase()==="f" && viewCam.classList.contains("active")){
        requestFullscreenOn(document.getElementById("streamCamWrap"));
      }
    });
  </script>
</body>
</html>
